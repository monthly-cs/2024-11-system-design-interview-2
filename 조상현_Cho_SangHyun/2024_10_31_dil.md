8p ~ 12p까지 읽음

### 1. DB master - slave 구조에서의 복제 시간 지연으로 인한 문제
책 8p에서는 master DB에 쓰기, slave DB에 읽기 요청을 처리시키는 구성을 사용할 때 master - slave 간 데이터 복제에 걸리는 시간 지연 때문에 문제가 생길 수 있음을 언급하고 있습니다. 책에서는 본인들이 가정한 상황이 사업장 정보가 실시간으로 갱신될 필요가 없는 상황이라 괜찮다고 넘어가지만.. 만약 실시간으로 갱신될 필요가 있는 경우라면 어떤 걸 고려해야 할지 궁금했습니다. 실제로 이런 문제는 현업에서도 많이 마주할 것 같아 어떤 대응 방법들이 있는지 간단히 살펴보고 생각해봤습니다. 

##### 1) 반동기 복제 (Semi-Synchronous Replication)
복제라는 것은 결국 Master가 Slave로 변경 내역을 전달해주는 건데요, Slave는 변경 내역을 로그에 먼저 작성을 한 뒤에 실제 변경 작업을 수행한다고 합니다(MySQL 기준). 이 때 slave가 실제 복제본 반영까지 다 끝나고 master로 "다 됐습니다" 하는게 동기 복제고, 비동기 복제는 master가 slave로 변경 내역 전달 후 응답을 받지 않는 방식입니다. 이 둘의 중간점에 있는 방식이 반동기 복제로, slave가 변경 내역에 대한 로그를 작성하고 나면 master에게 이를 알리는 방식입니다(동기 복제와는 다르게 실제 변경 작업까지 하고 알리는 게 아님). 이 때  master가 slave로부터 로그 작성 완료 메시지를 받은 뒤에 커밋을 하는 걸 `AFTER_SYNC`, 커밋을 한 뒤 slave로 변경 내역을 전달하고 로그 작성 완료 메시지를 기다리는 것을 `AFTER_COMMIT`이라고 합니다.

###### 1 - a) AFTER_SYNC

![image](https://github.com/user-attachments/assets/f6d5731d-e063-4459-8e1f-b457da5c5b3f)


###### 1 - b) AFTER_COMMIT

![image](https://github.com/user-attachments/assets/6190fb9a-9fc4-44d4-9fd2-a15faebfd5f7)


아무래도 반동기 복제는 클라이언트의 대기하는 시간이 시간이 동기 복제보다는 적겠으나 비동기 복제보다는 많을 것입니다. 그래도 비동기 복제에 비해서는 정합성 문제가 통상 덜 발생합니다. (변경 내역에 대한 전달을 확인받을 뿐이지 실제로 반영했는지에 대한 여부는 모르므로, 정합성 문제가 발생이 가능하긴 합니다)

즉.. write된 데이터를 정확하게 보여줘야 한다는 니즈가 있다면 어느 정도는 속도를 포기해야 하고, 무조건 빨리 보여주는 것이 1순위라면 정확도를 어느 정도는 포기해야 한다는 trade - off가 있습니다.

##### 2) 갱신된 데이터를 실시간으로 반영해서 읽어야 할 경우 master에서 직접 read
아무리 그래도 DB에 있는 모든 데이터에 대해 정확성이 요구되진 않을 것 같습니다. 읽기 연산 위주인 시스템이라고 가정하면, master가 쓰기 연산을 담당하는 상황에서 일부 읽기 연산을 받는다고 해서 큰 부담이 없을 것으로 생각되는데요. RDB라면 정확성이 요구되는 특정 테이블들에 대해 읽기를 하는 작업들을 master로 가게 하는 것도 괜찮은 방법 같습니다.



음..아무래도 설계적 관점이 더 풍부했다면 좀 더 여러 방안을 생각해볼 수 있을 것 같은데요 ㅠ.. 이번 스터디를 하고 나면 이런 문제에 대해서도 좀 더 다양한 방법을 고려할 수 있을 것 같아 기대됩니다 :)

<br/>  

### 2. PostGIS와 MySQL
- PostGIS : PostgreSQL에 GIS(Geographic Information System) 데이터를 저장 및 처리하는 기능을 제공하는 익스텐션

책 9p에서는 공간 데이터를 다룰 때 Redis 또는 PostGIS extension을 설치한 PostgreSQL을 사용한다고 적혀있습니다. MySQL도 공간 데이터 & 공간 쿼리에 대한 기능이 있어서 PostgreSQL과의 공간 데이터를 다룸에 있어서의 차이점이 궁금해서 간단히 알아봤습니다. 결론적으로는 MySQL에서 제공하는 공간 관련 기능들은 기본적인 수준인 반면 PostGIS extension을 설치한 PostgreSQL의 공간 관련 기능들이 (일반적으로) 성능도 좋고 더 많은 영역을 지원합니다.

- 공간 인덱스 : MySQL은 R-tree 기반의 공간 인덱스를 PostgreSQL + PostGIS은 GIST 및 SP-GiST 기반의 공간 인덱스 사용.
- 핸들링 가능한 데이터 유형 : MySQL은 Point, LineString, Polygon 등의 2차원 벡터 데이터들만 핸들링 가능한 반면, PostgreSQL + PostGIS는 3차원 벡터 데이터와 래스터 데이터(Raster data, 그리드 형태로 이루어진 공간 데이터)도 지원. 
- 추상적인 표현이나, **PostgreSQL + GIS가 좀 더 고도화된 공간 데이터 처리**가 가능하다고 합니다. 

<br/>  


### 3. 공간 데이터에 인덱스를 만드는 방법
책 9 ~ 11P에는 2차원 데이터라 함은 좌표(경도 위도로 이루어진) 데이터인데, 경도와 위도에 각각 인덱스를 걸어봤자 추출된 두 집합의 교집합을 구하는 것이 오래 걸리는 것을 언급합니다. 그래서 공간 데이터에 인덱스를 만드는 방법으로 다음 방법들을 소개하고 있습니다.

- Hash 기반 인덱스
	1. **균등 격자**
	2. **지오해시 (GeoHash)**
	3. 카르테시안 계층 (Cartesian tiers)
- Tree 기반 인덱스
	1. **쿼드트리 (Quadtree)**
	2. **Google S2**
	3. R-Tree (MySQL의 공간 인덱스가 R-tree를 기반으로 함)

공통적으로 2차원의 공간을 작은 영역들로 분할하고, 분할된 영역들을 기반으로 빠른 검색이 가능하도록 인덱스를 만든다는 컨셉으로 이해했습니다.

<br/>  


### 4. Hash 기반 인덱스와 Tree 기반 인덱스
인덱스가 검색을 빠르게 하기 위한 자료 구조로만 알고 있고, MySQL innoDB가 b+tree 기반 인덱스를 사용한다고만 알고 있어.. 이번 기회에 복습도 할겸 간단하게 둘의 차이점을 알아봤습니다.

##### 1) Hash 기반 인덱스
특정 컬럼의 값을 해시 함수로 변환하여 고유한 해시 값을 생성하고, 이를 인덱스로 사용하는 방식을 말합니다. 그렇다보니 특정한 한 값을 찝어서 검색하는 것은 굉장히 빠르나, 범위 검색에는 적절하지 않습니다. 사용자 아이디를 기준으로 사용자의 정보를 찾는 경우와 같이, key-value 검색이 많은 상황에서 적합한 인덱스라고 합니다.

##### 2) tree 기반 인덱스
예전에 MySQL의 인덱스를 정리할 때 사용했던 그림을 들고 오자면..

![image](https://github.com/user-attachments/assets/f58278de-1a90-4fc7-ab47-4ac6e4babc82)


요런 식으로 데이터를 정렬된 형태로 관리하는 구조이고, 범위 검색 등에 적합합니다. 다만 정렬된 형태로 애들을 관리해야 하므로, Hash 기반 방법에 비해 인덱스 생성이나 관리에 좀 더 많은 비용이 듭니다.


### 5. Hash 기반 공간 인덱스 - 균등 격자
지도를 작은 격자(셀이라고도 부름)들로 나눈 다음, 이를 기반으로 특정 영역의 데이터를 빠르게 검색하는 방향으로 사용할 수 있는 방법입니다. 왜 Hash 기반이라고 부르는지 궁금해서 찾아봤는데요. 각 격자들에 격자 식별자로 특정 id값이나 문자열을 부여한 뒤 좌표들을 이 격자들에 매핑시키는 형태로, 결론적으론 좌표들이 해싱되어 격자들에 매핑되기 때문에 Hash 기반이라고 부릅니다.

간단한 방법이긴 하지만, 책에서 제기된 것처럼 격자 식별자 할당에 명확한 체계가 없기 때문에(저는 Hash가 인풋이 조금만 달라져도 아웃풋이 크게 달라질 수 있기 때문에, 인접한 격자의 격자 식별자가 아주 다를 수 있음을 의미하는 것으로 이해했습니다) 특정 격자에 인접한 격자들을 알아내기 어렵다는 문제가 있습니다. 그렇다보니 특정한 좌표가 속한 격자에 데이터가 별로 없을 때, 인접한 격자들에 있는 데이터들을 땡겨오기가 힘들다는 단점이 있습니다. (뒤에 지오해싱을 쓱 보니 지오해싱은 이 문제를 해결할 수 있는 것 같네요)


