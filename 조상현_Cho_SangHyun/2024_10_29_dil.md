7p까지 읽음  


### 1. QPS(Query Per Second)
QPS자체보다는 DAU를 기준으로 하루 평균 검색량을 어림 짐작한 후 성능 측정에 활용하려고 하는 게 인상적이었습니다.  


최근 사내에서 동기적인 방식으로 메일과 카카오 알림톡을 보내는 작업을 비동기 + 병렬 처리로 바꾸는 작업을 했는데요, **"스레드 개수를 몇 개로 하는 것이 적절한가?"** 라는 의문이 생겼었습니다. 당시에 찾아봤을 땐

	CPU core 개수 X (1 + I/O 대기시간 / 실행시간)

으로 하면 이론적인 관점에서 CPU를 100%로 사용하는 스레드 개수를 계산할 수 있고, 목표로 하는 CPU 사용률이 있다면 그 값을 0.4 이렇게 저 수치에 곱하는 식으로 계산해줄 수 있더라구요? 물론 스레드 개수가 많아질 수록 각 스레드들도 메모리 공간을 사용해 작업을 수행하므로, 메모리 사용률이나 컨텍스트 스위칭 비용이 커지는 것도 고려해야 하겠지만.. 암튼 개인적으로, 목표로 하는 CPU 사용률을 설정해서 그에 맞는 이론적인 스레드 개수를 계산한 다음 테스트에 활용한다는 접근이 인상적이었습니다. QPS도 "사용자들이 하루에 몇 번 정도의 검색을 할 것이다"를 가정하고 산출하는 값이라 신선했고.. 개발하는 과정에서 성능을 테스트하는 일이 생길 때 이런 식으로 목표로 하는 값이나 예상되는 값을 설정해서 활용하는 습관을 들여야겠다는 생각을 했습니다.

</br>  

### 2. 읽기 연산 위주 시스템은 MySQL 같은 관계형 DB가 바람직
**"왜 읽기 연산 위주면 RDB가 바람직하다는 걸까?"** 라는 의문이 들었습니다.
처음에는 RDB와 NoSQL의 차이로 인한 특성 때문에 저렇게 말하는 것 같다는 생각이 들었습니다.
제가 아는 지식은 

1. RDB는 스키마를 설정해서 데이터들을 테이블들에다가 저장해서 사용하므로, 데이터들의 관계를 설정해줄 필요가 있거나 금전 거래같은 ACID를 만족해야 하는 요구사항이 있을 때 쓰기 좋다
2. NoSQL은 스키마를 유연하게 가질 수 있어 스키마 변경이 잦은 상황에 사용하면 좋고, 수평적 확장을 지원하므로 대규모의 데이터를 저장해야 하는 경우 사용하면 좋다. 또한 join 연산이 없으므로 아주 낮은 응답시간이 요구될 때 쓰면 좋다

정도였고.. "RDB는 데이터들을 여러 테이블로 저장하다보니 join 오버헤드가 증가할 수 있지만 NoSQL은 join이 없으므로 읽기가 더 빠르지 않나?" 라는 생각이 들었습니다. 실제로도 논문에서 MySQL과 MongoDB 등의 성능 차이를 측정한 결과를 보니 NoSQL이 빨랐습니다.

![image](https://github.com/user-attachments/assets/f4ae1c93-e765-4e0e-8674-6aae1c36e359)


그렇다면 단순히 성능만을 고려해서 저자가 RDBMS를 바람직하다고 한 것은 아니라는 생각이 들었고.. 그렇다고 저자의 의도에 대해 파내려하는 건 좀 아닌 것 같아.. 엄청 찝찝한데 일단 넘어가기로 했습니다.

</br>  

### 3. 로드밸런서의 역할
7p에서는 로드밸런서가 클라이언트가 요청한 URL을 기준으로 `/search/nearby`는 LBS로, `/businesses/{:id}`는 사업장 서비스로 전달하고 있습니다. 옛날에 로드밸런서가 URL을 기준으로도 트래픽 분배가 가능하다고 얼핏 들은 것 같긴 해서 이 참에 한 번 로드밸런서에 대해 살펴봤습니다.

로드밸런싱 : 애플리케이션을 지원하는 리소스 풀 전체에 네트워크 트래픽을 균등하게 배포하는 것

로드밸런싱의 장점은

1. 서버 문제를 자동으로 감지하고 클라이언트 트래픽을 사용 가능한 서버로 리디렉션하여 시스템의 내결함성을 높일 수 있다
2. 한 서버에 트래픽이 몰리는 현상을 방지하고, 서버 간에 로드를 균등히 분배하여 앱의 성능을 높일 수 있다
3. 애플리케이션에 보안 기능을 내장시켜 트래픽을 모니터링하고 악성 콘텐츠를 차단할 수 있다

로드밸런싱의 종류는 다음 항목들이 있습니다.

#### 1) 애플리케이션 로드밸런싱
HTTP 헤더같은 요청 콘텐츠를 확인하여 트래픽을 리디렉션하는 것. HTTP 요청 헤더는 다음과 같은 구조로, Host 항목이 필수적으로 들어가기 때문에 이를 토대로 트래픽 분배가 가능합니다. L7 로드 밸런서라고도 부르고, 책의 7p에서 사용한 로드밸런싱이 애플리케이션 로드 밸런싱입니다

```bash
GET /search?q=hello HTTP/1.1 
Host: www.naver.com
```

#### 2) 네트워크 로드 밸런싱
IP 주소 및 기타 네트워크 정보를 검사하여 트래픽을 리디렉션하는 것. L4 로드 밸런서라고도 부릅니다.

#### 3) 글로벌 서버 로드 밸런싱
클라이언트와 지리적으로 더 가까운 서버 대상으로 트래픽을 리디렉션하는 것. 

#### 4) DNS 로드 밸런싱
하나의 도메인에 여러 ip 주소들이 바인딩되어 있을 때, 같은 도메인으로 들어와도 서로 다른 ip로 전달시켜서 한 서버에만 부하가 몰리는 걸 방지하는 방법입니다.

실제로 `nslookup www.naver.com`을 하면, 네이버 도메인에 여러 ip가 물려있는 걸 볼 수 있습니다
<img width="669" alt="image" src="https://github.com/user-attachments/assets/e1efd4c5-1012-4c29-aa42-dca67c8924f2">

