
73 ~ 101p 읽음


### 1. 지오코딩 - interpolation (77p)
지오코딩은 주소를 좌표값으로 바꿔주는 것을 말하며, 대표적인 방법으로 책에서 설명하는 `interpolation`이 있습니다. 찾아보니 한국말로는 보간법이라 부르는데요, 주소와 직접 매핑되는 정확한 좌표가 없을 때 주변의 이미 알려진 좌표 값을 활용해 추정 값을 계산하는 방법이라고 합니다. 

<br/>  

### 2. 도로 데이터 처리 방법 (79p)
경로 탐색은 교차로를 노드, 도로를 엣지로 하는 그래프 자료 구조를 기반으로 이루어집니다. 책 74p에서는 도로 데이터들을 raw 데이터로 준비해뒀다고 하고 있으니, 이 경우엔 해당 raw 데이터들을 그래프 형태로 변환하는 작업이 필요합니다. 세계의 모든 도로를 하나의 그래프로 나타내는 것은 메모리와 성능에 모두 취약하므로, 공간을 여러 격자로 나누고 그 격자안의 도로망을 그래프로 매핑시켜 최종적으론 여러 그래프를 관리하는 형태를 사용할 수 있습니다. 그리고 도로의 구체성(주요 고속도로만 두거나, 관할구를 잇는 도로들만 두거나, 지방도 도로만 두거나)에 따라 분류하여 경로 안내를 하는 기법도 사용할 수 있습니다. 

<br/>  

### 3. 세계 지도 이미지 저장 (82p)
세계 지도 이미지를 사용하는 것도 하나의 큰 이미지를 사용하는 게 아니라 지도를 여러 이미지로 분할해서 필요한 부분만 사용하는 방식을 사용할 수 있습니다. 단 사용자가 얼만큼 지도를 확대했는지, 그 확대 수준에 따라 여러 수준의 지도 타일 이미지들을 준비해둬야 합니다. 

책 83p에서는 사람이 거의 살지 않는 바다, 사막 등에 대한 이미지는 고비율 압축이 가능하다고 하는데요. 이 말이 처음에는 저 지역은 별로 확대를 안 할 거니까 그런건가? 그럼 이유는 뭐지? 해서궁금해서 찾아보니.. 바다 = 거의 다 파란색, 사막 = 거의 다 노란색이고 둘 다 명암 비율이 거의 없어.. 이 이미지들은 저장하는데 중복 패턴들을 다른 이미지보다 더 많이 제거할 수 있어서 고압축이 가능하다고 합니다. 

<br/>  

### 4. 위치 서비스 (86p)
사용자 위치가 바뀔 때마다 위치 정보를 서버로 보내면 부하가 너무 커지기도 하고 굳이 그럴 필요가 없으니, 클라이언트에서 매 초 위치 정보를 모았다가 일정 시간 간격(책에서는 15초)으로 일괄 요청을 보내는 기법을 사용 가능합니다. 이 때 HTTP keep alive로 서버와 계속해서 TCP세션을 맺은 상태에서 요청을 지속적으로 보내는 방법을 사용할 수 있다고 책에서는 설명하고 있습니다. 추측컨대 3 way handshake 부하를 줄이려는 목적이 있다고 생각합니다만, 서버에서 연결을 열어두는 데 필요한 리소스를 다른 클라이언트가 사용할 수 없게 된다는 단점이 있습니다. 15초마다 위치 정보 변경분들을 보낸다면.. 개인적으로는 굳이 keep alive를 해야 하나라는 생각을 해봤습니다. 

<br/>  

### 5. CDN 도입 시 고려할 것들 (89p)
책에서는 CDN을 통해 미리 만들어둔 지도 이미지들을 클라이언트에게 전달하는 형태를 보여줍니다. CDN이 사용자랑 지리적으로 가까운 곳에 정적 자원들을 캐싱하는 것으로 알고 있는데요, 어떠한 때에 사용하는지를 정리하면 설계적인 지식이 좀 생기지 않을까란 생각에 CDN 도입 시 고려할 내용들을 간단히 알아봤습니다.
<br/>  

#### 1) CDN 장점
- 사용자와 가까운 서버(엣지 서버라고도 부름)에서 콘텐츠를 제공하므로 지연을 줄일 수 있음. 서비스가 글로벌 서비스인 경우 전 세계 사람들이 비슷한 지연시간 내에 콘텐츠를 제공받을 수 있음
- 원본 서버 대신 CDN 서버에서 캐싱을 활용해 요청을 처리할 수 있으므로 원본 서버의 트래픽 부담을 줄일 수 있음
- 보통 정적 컨텐츠 캐싱에 많이 쓰긴 하나, 동적 컨텐츠도 일부 캐싱 가능(URL의 쿼리스트링 기반의 캐싱 등)

#### 2) 어떤 경우 CDN 도입하면 좋은가?
콘텐츠를 캐싱해 지연을 줄이고 싶은 상황인데,

- 대량의 정적 콘텐츠를 서비스하는 경우
- 글로벌 서비스라 사용자들이 여러 국가에 있는 경우

이럴 때 사용하면 효과를 볼 수 있습니다.

#### 3) CDN으로 효과를 보기 힘든 경우
결국 콘텐츠를 캐싱해서 사용하는 것이므로, 실시간 처리처럼 캐시의 효과를 보기 힘든 경우는 권장되지 않습니다. 또한 특정 국가 또는 지역만을 대상으로 서비스하는 경우는 CDN의 필요성이 적다고 할 수 있습니다.

<br/>  

그리고 이 장에서는 CDN에서 지도 이미지를 가져오는 URL에서의 지오해시 계산을 클라이언트에게 맡기면 여러 플랫폼(웹, 모바일..)에 대한 구현을 하나하나 해야 하는 문제가 생기니, CDN URL을 따로 계산하는 서비스를 별도로 둬서 유연성을 높이는 방법을 보여주는데요. 막 어려운 건 아닌데.. 이런 기법(?)을 쓰면 좀 더 유연한 구조를 만들 수 있겠다는 생각이 들어 인상적이었습니다.

<br/>  

### 6. CP, AP시스템에 적합한 DB (97p)
97p에는 AP시스템에 적합한 DB로 카산드라를 소개해주고 있습니다. 개인적으로는 분산 시스템에서 P는 챙길 수밖에 없는 상황에서 C나 A를 골라야 하는 것을 이번에 알게 되어.. 내친 김에 각 시스템별로 적합한 DB가 어떤 게 있는지 알아봤습니다. 반드시 이 DB는 이 시스템이다! 라기 보다는 일관성에 관한 옵션을 달리 함에 따라 CP로도, AP로도 활용 가능했습니다.

#### 1) CP 시스템
- MongoDB
	- 프라이머리와 세컨더리 노드로 구분 가능하며, 기본적으로 write는 프라이머리 노드에서만 수행됨
	- 프라이머리가 다운되면 세컨더리 노드 중 하나가 승격되는데, 이렇게 프라이머리가 없는 시간동안은 모든 쓰기 작업은 잠시 사용 불가능한 상태가 됨
	- write concern, read concern을 통해 일관성을 강화 가능함 (쓰기 시 특정 개수의 노드에 쓰여져야 인정된다든가, 읽기 시에도 특정 개수의 노드에 해당 데이터가 있어야 인정된다든가..)
	- https://www.mongodb.com/ko-kr/docs/manual/core/replica-set-primary/
	- https://www.mongodb.com/ko-kr/docs/manual/reference/read-concern/

#### 2) AP 시스템
- 카산드라
	- Master없이 모든 노드가 읽기 작업과 쓰기 작업을 수행할 수 있고 복제본을 분리된 다른 노드에 저장
	- 네트워크 장애로 노드 간 통신이 안 되도 각 노드들은 여전히 읽기/쓰기 가능. 이때 일관성이 깨질 수 있으나 카산드라는 나중에 통신이 정상화되면 이를 복구해 최종적 일관성을 지킴
- DynamoDB
	- 카산드라처럼 데이터를 여러 노드에 복제하여 네트워크 장애 시에도 각 노드는 읽기와 쓰기를 보장
	- 디폴트 설정이 Eventual Consistency인데, 쓰기 작업 후 데이터 일관성이 즉시 보장되지 않으며 시간이 지나면서 점진적으로 동기화하는 모드임. 
	- Strongly Consistent Read를 설정하면 일관성을 강화할 수 있음
	- https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html

<br/>  

### 7. WebGL (100p)
어떤 기술인지 잘 몰라서 간단하게 조사해봤습니다.

- 웹 브라우저에서 3D, 2D 그래픽을 렌더링하기 위한 JavaScript API. 이미지를 전달받아 보여주는 게 아니라, 이미지를 구성하는 요소들의 정보를 전달해주면 이를 토대로 이미지를 만들어서 보여주는 기술
- 이때 GPU를 활용해 병렬로 렌더링 작업(그래픽 연산)을 분산시킬 수 있음. 이때 CPU는 다른 일 가능
- 이미지를 구성하는 요소들(텍스트 또는 벡터)은 이미지보다 용량이 훨씬 더 작아서 네트워크 대역폭을 아낄 수 있음

다만 책 75p에서는 클라이언트는 가능한 최소한의 데이터와 배터리를 사용해야 한다고 했으니.. 물론 실제로는 어떨지 모르겠으나 배터리 측면에서 보면 GPU를 사용하는 것이 더 안 좋겠다는 생각이 개인적으로 들었습니다. 책에서는 지도 이미지에 png파일을 사용하는데, 찾아보니 webp파일을 쓰면 png와 품질은 비슷하되 용량은 줄일 수 있다고 해서, webp파일을 사용하는 것도 하나의 대안이 될 듯 합니다.

