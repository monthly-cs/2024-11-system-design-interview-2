128 ~ 137p 읽음

### 1. 일괄처리 (128p)
메시지 발행 / 구독을 일괄로 처리하면 하나하나 반복적으로 처리하던 것을 한 번에 묶어서 처리할 수 있으므로, 네트워크 I/O나 디스크 I/O가 줄어 성능 향상을 꾀할 수 있습니다. 이 경우 대역폭이 높아지는 효과(한 번에 대량으로 처리하므로)를 가져오나 각 메시지 입장에서는 일괄 처리될 때까지 기다리는 셈이 되므로 지연 시간은 높아지는 부작용을 가져오게 됩니다. (즉 둘 사이에 Trade-Off)  

생산자 입장에선 자신의 메모리 버퍼에 메시지를 보았다가 일괄 발행시켜 대역폭을 높일 수 있고, 소비자 입장에선 특정 개수만큼씩 묶어서 이벤트를 가져올 수 있습니다.

<br/>  

### 2. 데이터 가져오기 - push & pull (131p)
브로커가 소비자에게 메시지를 직접 밀어주는 걸 push, 소비자가 브로커로부터 메시지를 직접 가져오는 걸 pull이라고 합니다.   

- push : 메시지가 발행되자마자 소비자에게 밀어줄 수 있으니 지연이 낮다는 장점이 있으나, 데이터 공급의 주도권이 브로커에게 있는 만큼 소비자가 감당 가능한 양 이상으로 데이터를 넣어줄 수 있는 단점이 있습니다.
- pull : 데이터 공급의 주도권이 소비자에게 있으니 자신의 속도에 맞게 브로커로부터 데이터를 가져올 수 있고, 일괄 처리에 적합하다는 장점이 있습니다. 반면 브로커에 메시지가 없어도 소비자가 데이터를 가져가려 시도할 수 있으며 이는 컴퓨팅 자원의 낭비(하지 않아도 되는데 하는 것이므로)가 된다는 단점이 있습니다.

책에선 롱 폴링을 통해 이 pull의 단점을 어느 정도 해소 가능하다고 설명하고 있습니다.

- 폴링 : 주기적으로 방문해서 "내가 가져갈 거 있니?"하는 것
- 롱 폴링 : 서버에 요청을 보내고 서버가 새로운 데이터가 있을 때까지 응답을 지연시키는 방식

메시지 브로커로 자주 쓰이는 애들은 어떻게 가져오는지도 알아봤습니다.

- Redis pub/sub : push
- RabbitMQ : 둘 다 가능, 일반적으론 push
- Kafka : pull

참고
- https://aws.amazon.com/ko/compare/the-difference-between-kafka-and-redis/
- https://vvekpandey.medium.com/rebbitmq-vs-kafka-vs-redis-pub-sub-how-are-they-different-0f01544f6fd1

그리고 저번 주 스터디(11/21)에서 람다는 어떻게 활용하는지에 따라 push / pull이 결정된다고 들었던 것 같아서 간단히 조사해봤습니다. 

- 대표적으로 S3 이벤트 트리거와 연결 -> push 방식으로 동작됨
- 대표적으로 키네시스 스트림 -> pull 방식으로 동작됨

https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html

<br/>  


### 3. 카프카의 코디네이터 failover (133p)
소비자가 추가되거나 삭제되거나 특정 소비자에 장애 발생 시 소비자 재조정(Consumber Rebalancing)을 통해 어떤 소비자가 어떤 파티션을 담당할지를 다시 정할 수 있음을 소개합니다. 이 프로세스에 그룹 코디네이터가 활용되고, 그룹 코디네이터는 특정 브로커 노드가 담당한다고 소개되어 있습니다. 코디네이터는 모~든 소비자 그룹에 대한 역할을 하는 게 아니라, 각 소비자 그룹의 해시값에 매팽되는 브로커만 그 소비자 그룹의 코디네이터 역힐을 합니다 (즉 a그룹은 1번 브로커가 코디네이터 역할을, b그룹은 2번 브로커가 코디네이터 역할을 할 수 있고, 재수없으면 1번이 다 할 수도 있음)

그러면 특정 그룹의 코디네이터로 쓰이는 브로커가 죽으면 failover가 어케 되는지도 한 번 보고 싶어서 간단하게 알아봤는데요. (카프카 기준으로 알아봄) 코디네이터 브로커가 담당하던 파티션의 사본을 갖고 있는 브로커가 다시 리더가 된다고만.. 합니다 ㅎㅎ

![image](https://github.com/user-attachments/assets/cc626abf-56e8-4f55-a7f6-a518702b82e2)


https://developer.confluent.io/courses/architecture/consumer-group-protocol/

