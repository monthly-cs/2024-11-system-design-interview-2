207p ~ 226p

## 1. 람다 아키텍쳐 vs 카파 아키텍쳐
#### 1)초기 빅데이터 플랫폼들이 사용하던 방식
- 각 엔드시스템으로부터 나오는 데이터들을 배치로 모아하여 다른 DB로 보냄
- 유연하지 못하고 실시간 처리가 안 된다는 단점 존재
- 원천에서 파생된 데이터의 히스토리 파악 등이 어려웠다는 단점도 있었음
<img width="690" alt="image" src="https://github.com/user-attachments/assets/1d5c7439-9bb6-4a8b-aba9-8d00ac45fb4b">


#### 2) 람다 아키텍처
- 배치 레이어 : 데이터를 모아서 특정 주기마다 일괄처리
- 서빙 레이어 : 가공된 데이터를 서비스 앱이 사용할 수 있도록 저장된 공간
- 스피드 레이어 : 서비스에서 생성되는 원천 데이터를 실시간 분석하는 용도. 배치 레이어에 비해 낮은 지연으로 분석 가능. 보통 카프카 같은 이벤트 스트리밍 플랫폼이 위치
- 배치, 스피드 레이어라는 2개로 분리된 레이어로 인한 2벌의 로직이 필요하다는 단점
- 배치, 실시간을 융합해서 처리하는 것도 힘들었다
<img width="659" alt="image" src="https://github.com/user-attachments/assets/bac26dff-2aa8-4165-aebc-047cbbfee090">



#### 3) 카파 아키텍처
- 람다의 단점 = 로직의 파편화. 이거 막기 위해 배치 레이어를 제거했다
- 스피드 레이어에서 모두 처리한다는 컨셉 > 스트림 데이터를 서빙 레이어에 저장
<img width="665" alt="image" src="https://github.com/user-attachments/assets/adc793a9-2bbe-41f5-90f5-8ef6251bf1d5">

<br/>  
<br/>  



## 2. 텀블링 윈도, 슬라이딩 윈도
윈도우 : 데이터 스트림 처리 혹은 시계열 데이터 분석에서 사용되는 개념. 데이터를 소화 가능한 단위로 분할하여 그룹을 만들고 분석하는 방식

- 텀블링 윈도 : "겹치지 않는" 고정된 시간 간격으로 윈도우를 사용하는 것

![image](https://github.com/user-attachments/assets/eda172e9-6d09-420b-9457-6417e00869b1)


- 슬라이딩 윈도 : "겹치는" 시간 간격으로 윈도우를 사용하는 것
  
![image](https://github.com/user-attachments/assets/c377804f-5503-4200-8242-c29abedb48a6)

<br/>  

## 3. 분산 트랜잭션
2개 그 이상의 네트워크 상의 시스템 간의 트랜잭션을 말함  
대표적으로 2PC와 saga pattern이 있다

#### 1) 2 phase commit
![image](https://github.com/user-attachments/assets/8002e21e-81a2-47ab-a52f-97d252730fcb)

트랜잭션 처리 순서는 Prepare Phase > Commit Phase 순으로 진행 (그래서 2 phase)

1단계 : 준비 단계
- 트랜잭션 코디네이터가 DB들에게 준비됐는지 묻는 단계
- 각 참여자는 작업 실행 후 yes or no를 응답, 커밋은 아직 안 한 단계
- no라고 하는 경우 : 메모리or디스크 문제로 작업을 처리할 수 없거나, 중복된 키를 삽입하는 경우 등 제약 조건으로 실패하는 경우 등에 no를 응답. 

2단계 : 커밋 단계
- 1단계에서 참여자들이 모두 yes를 하면 커밋하라고 오더 내림
- 1단계에서 하나라도 no를 했으면 롤백 오더 내림

#### 2) saga pattern
- 서비스 간의 이벤트를 통해 각 시스템들이 로컬 트랜잭션들을 순차적으로 처리
- 하나 뻑나면 보상 트랜잭션이란 개념을 통해 롤백
	- 보상 트랜잭션 : 정상적으로 수행된 서비스의 트랜잭션을 취소 혹은 되돌리는 트랜잭션을 말함
- 트랜잭션을 통해 데이터베이스가 자동으로 해주던 롤백을 직접 구현해야 함. 즉 트랜잭션의 관리 주체가 데이터베이스가 아닌 어플리케이션


