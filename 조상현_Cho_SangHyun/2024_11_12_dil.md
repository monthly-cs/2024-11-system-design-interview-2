
### 1. 서비스 탐색 컴포넌트
책 59p에서 서비스 탐색 컴포넌트라는 말이 나오고.. 주키퍼(ZooKeeper)를 제일 많이 쓴다고 해서 서비스 탐색 컴포넌트가 어떤 것인지 알아봤습니다. 서비스 탐색 컴포넌트라는 표현보다는 분산 코디네이션 서비스라고 더 많이 불리고 있고, **"분산 시스템에서 시스템 간의 정보 공유, 상태 체크, 서버들 간의 동기화를 위한 락 등을 처리해주는 서비스"** 라는 의미를 가진다고 합니다. 이 책에서도 주키퍼가 가용한 Redis pub/sub 서버들의 목록을 보관하여 웹소켓 서버들이 정보를 공유하게 해주는 역할을 해줍니다. 이 놈도 분산 시스템의 일부이고 장애가 나면 다른 서비스들에 영향을 줄 수 있으므로 클러스터로 구축해서 가용성을 높이도록 설계할 필요가 있습니다.

<br/>  


### 2. Consistent Hashing와 Hash ring
책 60p에서 Consistent Hashing과 Hash ring에 대한 언급이 나오는데요. 예전에 샤딩을 할 때 한 샤드에 데이터가 너무 몰려서 샤드를 재분배하는 문제를 Consistent Hashing으로 해결 가능하다는 말을 들은 적이 있어 내친 김에 알아봤습니다.

우선 분산 시스템에서 특정한 값이 해시값에 따라 어느 노드로 갈지 결정한다고 할 때, 대표적으로 모듈러 연산을 통한 해시를 사용할 수 있습니다. 

> ex) 3으로 나눈 나머지에 따라 노드를 정한다고 할 때
> 1 -> 1번 노드
> 2 -> 2번 노드
> 3 -> 0번 노드
> 4 -> 1번 노드..

하지만 이 방법은 **노드의 수가 변하면 기존에 있던 데이터들을 재분배해야 하는 문제**가 있으며, 이들을 하나하나 보면서 재분배를 해줘야 합니다. 따라서 노드 수에 의존하지 않는 해싱 방법이 필요하며 이 때 해시 링을 쓸 수 있습니다.

<img width="598" alt="image" src="https://github.com/user-attachments/assets/78cad187-df56-4720-a00c-e0ca28a0290f">

이미지처럼 각 노드(키로도 이해 가능하며 이미지에선 A, B, C)와 데이터(Jane, Kate 등)를 특정 해시값으로 변환해 링 위에 배치하고, 데이터들이 놓인 위치(해시값 범위)에 따라 어느 노드에 분배될지를 결정하는 방식입니다. 만약 위 이미지에서 C가 사라진다고 하면 C에 붙어있던 John과 Steve만 A로 붙여주면 되고, 특정 노드가 추가된다고 하면 해당 범위에 있는 애들만 다시 붙여주면 됩니다. 즉 기존 방법과는 달리 모든 데이터에 대해 재배치를 하지 않고 특정 범위에 해당하는 데이터들만 재배치해줄 수 있으므로 재배치에 대한 오버헤드를 줄일 수 있습니다.

다만 단점도 있는데요. 데이터를 균등히 저장하지 못할 수 있다는 단점(해시 특성상 어쩔 수 없다고 생각됩니다)과 노드가 삭제되는 순간에는 인접한 다른 노드로 삭제된 노드에 붙어있던 데이터들이 달라붙게 되어 그 노드에 대한 부하가 커질 수 있고, 최악의 경우 이게 연쇄적인 노드 죽이기(?)가 될 수 있다는 단점이 있습니다. 이는 실제 노드가 여러 개의 논리적인 virtual node들을 만들고, 얘네들을 링 위에 무작위하게 뿌리는 방식으로 어느 정도 보완 가능하다고 합니다.

개인적으로는 분산 시스템을 접해본 적이 거의 없어서 재밌게 본 부분같습니다..!

<br/>  

### 3. 유상태 서버 클러스터의 스케일 아웃(규모 확장)
책 62p에서는 Redis pub/sub 클러스터의 스케일 아웃 고려사항에 대한 얘기가 나오는데요, 이 경우 노드(서버)를 추가 또는 삭제하게 되면 기존의 pub/sub 서버가 갖던 채널들이 새 서버로 이동하는 것에 대한 처리를 고려해야 한다는 내용이 나옵니다. 구체적으로는 처음부터 큼지막하게 프로비저닝하든가, 정 서버를 추가해야 한다면 트래픽이 거의 없을 때 하는 방법을 추천하고 있습니다. 근데 책 54p에는 웹소켓 클러스터의 경우 같은 유상태 서버 클러스터임에도 불구하고 노드 추가에 대해 이렇게까지 얘기하지는 않아서 다시 봤었는데요. 아무래도 웹소켓 서버는 신규 서버를 추가해도 로드밸런서 쪽에서 Least-connections같은 알고리즘을 사용하면 기존 서버로 연결 요청이 가는 걸 최대한 줄일 수 있고, 노드를 삭제해야 하는 상황 등에선 draining을 걸어서 해당 서버의 연결들이 끊기는 것을 기다릴 수 있다보니..  결국은 같은 "유상태"여도 그 성격에 따라 스케일 아웃이 비교적 간단할 수도, 어려울 수도 있음을 개인적으론 느낀 것 같습니다.

 개인적으로 스케일 아웃이라 함은 (해본 적 없지만) CPU 사용률 같은 메트릭에 따라 서버 추가하거나 삭제하면 되는 거 아니냐는 막연한 생각을 하고 있었습니다. 근데 이 부분을 읽고 나니.. 제가 했던 생각은 무상태인 서비스를 제공하는 서버일 경우에 많이 사용 가능한 방법이고, 유상태 서비스를 제공하는 경우는 상태를 이미 가지고 있는 (채널을 가지고 있거나 클라이언트와 연결을 맺고 있거나) 서버들의 성격 등을 고려해야 함을 알게 돼서 좋았던 것 같습니다.

