~~54p

⛳️ 세줄 평!

1. 데이터 갱신 횟수를 줄이기 위해서 `메세지 발행/구독`과 `웹 소켓`을 사용한다.
2. 데이터 조회를 감당하기 위해서 `인메모리 DB`를 사용한다.
3. 위치 로그는 `OLAP DB`에 사용자 정보는 `OLTP DB`에 저장한다.

# 2단계 개략적인 설계안 제시 및 동의 구하기

## 2.1. 접근 전략

가상 설계 면접을 `30분`으로 진행한다면, 2단계는 `10분`을 할애할 것 같습니다.

이 시간 동안 가장 어려운 `기술적 난제`를 면접관과 확정하고 이를 `해결하는 아키텍처`에 대해서 다룹니다.

따라서 개인적으로 아래의 순서에 맞춰서 설계를 그려가는 것이 좋다고 생각합니다.

1. 기술적인 난제 선정 및 근거에 대한 생각 공유
2. 기술적인 난제를 해결하기 위한 핵심 아키텍처 설계
3. 부수적인 문제를 해결하기 위한 보조 아키텍처 설계

## 2.2. 실제 접근

### 2.2.1. 기술적인 난제 선정 및 근거에 대한 생각 공유

이 문제를 어렵게 만드는 특성은 크게 4가지로 구성되어 있습니다.

1. 많은 수의 사용자 가정
2. 많은 수의 친구 숫자 가정
3. 많은 수의 위치 정보 갱신
4. 저지연시간

요구사항 대로면 위치 정보는 `초당 33만 4천`번 갱신됩니다. <br>
하지만 갱신된 정보는 평균 400명에게 갱신되어야 하기에 `초당 1억 3360만`번 조회됩니다. <br>

또한 30초 마다 갱신되는 정보는 최대 29초 안에 모든 처리가 되어야 합니다. <br>
따라서 기술적인 난제는 `갱신을 줄이는 방향`과 `조회를 처리하는 방안`이 모두 고려되어야 합니다.

### 2.2.2. 기술적인 난제를 해결하기 위한 핵심 아키텍처 설계 - 갱신을 줄이는 방향

위치기반 서비스는 GPS에 의존하고 GPS의 오차범위를 제약사항으로 가지게 됩니다. <br>
따라서 유저의 움직임을 어느 정도까지 `정밀`하게 기록하고 추적할지를 지정해야 합니다. <br>
이 `정밀도` 이하의 움직임에 대해서는 움직이지 않은 것으로 간주해도 무방하다고 생각합니다.

저는 `친구와 나의 거리`의 정밀도는 `10m` 단위로도 충분한 사용자 경험을 제공할 수 있다 가정했습니다. <br>
또한 이로 인해서 각 사용자의 위치 오차는 위,경도로 `5m` 정도의 오차를 감내하고 시스템을 설계하고자 합니다.

위에서 말한 대로면 오직 `움직인 순간`에만 그 정보가 갱신되어야 합니다. <br>
즉, 사용자의 위치는 매 30초마다 갱신될수도 갱신되지 않을 수 있습니다. <br>
이를 위해서 저희는 펍섭 패턴(Publish Subscribe Pattern)을 활용합니다. <br>
구독 이벤트가 트리거 되는 시점에만 데이터 조회를 시작해야 합니다.

### 2.2.3. 기술적인 난제를 해결하기 위한 핵심 아키텍처 설계 - 조회를 처리하는 방안

조회에서 발생하는 QPS는 최대 `초당 1억 3360만`번입니다. <br>
이 정도의 TPS를 일반적인 관계형 디스크에서 처리하는 것은 비효율적입니다.

인메모리 DB를 사용하면 8단위면 충분하지만, 관계형 DB를 사용하면 16단위가 필요합니다. <br>
인메모리 DB의 조회/쓰기 속도는 관계형 DB의 메모리 계층 조회/쓰기 속도보다 5~7배 정도 차이가 납니다. <br>

어차피 5GB 정도의 데이터를 저장하는 것이기에 인메모리 DB를 조회계층에서 사용하는 것은 효율적으로 보입니다.

> 유저 1명의 위치 정보 크기
> - UUID 128 bit = 16 byte
> - 위도, 경도는 float 이기에 각 8 byte로 총 16 byte
> - Unix Timestamp 4 byte/8 byte (32bit/64bit) <br><br>

> 전체 유저의 위치 정보 크기
> - 100,000,000 * 50 byte = 5,000,000,000 byte
> - 5,000,000,000 byte / 1000 KB/byte = 5,000,000 KB
> - 5,000,000 KB / 1000 MB/KB = 5,000 MB
> - 5,000 MB / 1000 GB/MB = 5 GB <br><br>

> **왜 비효율적일까?** <br>
> MySQL은 InnoDB를 사용하면 버퍼풀이라는 메모리 계층이 존재합니다. <br>
> 이 메모리 계층에 5GB를 할당하려면 최소 16 GB 가 넘는 데이터베이스를 운영해야 합니다. <br>
> - 5GB / 0.7 = 7.1428 GB (DB Level)
> - 7.1428 / 0.7 = 10.204 (OS Level)
> _p.s. 상용 DB는 메모리가 2 단위로 증분되기 때문에 8보다 큰 10.204 공간을 위해서는 16 공간을 쓰게 된다._ <br><br>

### 2.2.4. 부수적인 문제를 해결하기 위한 보조 아키텍처 설계 - 위치 로그 기록

앞서 머신 러닝 학습을 위해서 위치 정보를 기록한다는 내용이 있었습니다. <br>
따라서 이 부분은 로그 시스템의 일부로서 해석하고 OLAP 기반의 데이터베이스를 배정하는 것이 합당합니다. <br>
다만 OLAP DB는 쓰기 속도도 느리기 때문에 이 부분은 메세지 스트림을 앞단에 배정하는 것으로 개선할 수 있습니다.

### 2.4.5. 부수적인 문제를 해결하기 위한 보조 아키텍처 설계 - 사용자의 상태 유지

사용자의 기계가 인메모리 DB를 구독할 수 있도록 웹 소켓 서버로 설계해야 합니다.

### 2.4.6. 부수적인 문제를 해결하기 위한 보조 아키텍처 설계 - 사용자의 메타 정보 저장

사용자의 메타 정보는 전통적인 OLTP 기반의 ACID가 보장되는 데이터베이스를 배정해야 합니다. <br>
